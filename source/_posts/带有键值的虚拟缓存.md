---
title: 带有键值的虚拟缓存
tags:
  - 技术
  - 学习
categories:
  - 缓存与内存专栏
date: 2023-08-17 20:52:15
---


虚拟缓存存在一个很大的问题，由于每一个进程都拥有独立的地址空间。当上下文切换后，必须对缓存进行刷新。一个很简单的想法就是把pid和虚拟地址结合起来作为索引进行缓存查找，从而减少刷新缓存的次数。

## 带有键值的虚拟缓存的基本操作

首先是硬件结构的变化，由于需要支持键值，每个cache line的tag都会增加一个进程键值用于区分不同的进程。同时我们需要一个新的寄存器来保存这个进程键值，如下图所示：

![带有键值的虚拟缓存](https://s2.loli.net/2023/08/17/DMP4FEZoe96C5XQ.png)

带有键值的虚拟缓存除了其加了一个新的键值以外其本质与虚拟缓存的操作没有差别。其仍然通过虚拟地址进行索引，然而由于有额外的键值信息可以判断当前缓存是否属于当前进程。一个美好的愿望是硬件为系统中的每一个进程都生成一个独一无二的标识符，这样我们就不会产生歧义和别名。愿望始终是愿望，硬件能够提供的标识符往往数目很少，有些硬件仅仅支持8个标识符。所以会有某些进程共享同一个标识符，我们仍然会面临虚拟缓存的歧义和别名问题。

## 操作系统与带有键值的虚拟缓存的交互

### 上下文切换

当键值充足时，我们可以为每一个在系统中运行的进程分配一个独一无二的键，这样上下文切换的时候，对于*write-through*而言，我们都不需要刷新缓存，仅仅只需要改变寄存器中的进程键值即可。

当键值不够使用时，操作系统需要重新分配键值。一个常见的思路是换入和换出，我们仍然需要将某个键值换出，然后把所有有关于该键值的缓存进行刷新。对于*write-through*而言，我们做的操作会比较简单，我们直接可以直接把cache line的valid位置为0。对于*write-back*而言，我们还需要写入内存。实际上，你会发现，这样也带来了另外的复杂度，操作系统应该换出哪个键呢？

对于采取*write-back*的写策略，还有一个更加严重的问题。当我们对进程A进行了上下文切换后，其cache line的值可能已经被改变了，然而很有可能另一个进程B会刷新这个cache line，但是对于进程B而言，操作系统并没有进程A的页表信息，操作系统无法知道该写入哪个具体的物理内存。因此，大多数采取带有键值的虚拟缓存会采用*write-through*策略。

有些硬件提供了额外的机制，既然目前已经有键值信息，就可以把键值信息和页表信息组成一个映射，这样对于上述情况，就能够找到物理地址，从而写入数据。然而，却极大地增加了硬件负担。

### 共享内存

对于虚拟缓存而言，两个进程之间共享内存会因为上下文切换时自动对缓存进行刷新的机制避免别名问题，然而带有键值的虚拟内存会更加的复杂。

对于直接映射缓存而言，我们假设两个进程的相同的虚拟地址指向相同的物理地址。同时假设操作系统给进程$A$分配的键值为1，给进程$B$分配的键值为2。我们可以明确地知道由于虚拟地址相同，其找到的cache set必然相同，由于每个cache set只有一个cache line。如下图所示，当进程A切换到进程B时，进程B访问该虚拟地址，由于键值不同，会导致cache miss，然后读取**相同的物理内存**到cache中。然而，物理内存没有发生任何的改变。

![共享内存-直接映射虚拟缓存](https://s2.loli.net/2023/08/17/iyScjte1s5PT3rD.png)

然而，大多数情况这两个进程的虚拟地址是不相同的，这样就和虚拟缓存的情况一样了，会产生别名的情况。当我们需要使用共享内存时，cache在一定程度上就失效了。
