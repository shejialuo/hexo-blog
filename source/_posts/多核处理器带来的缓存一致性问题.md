---
title: 多核处理器带来的缓存一致性问题
tags:
  - 技术
  - 学习
categories:
  - 缓存与内存专栏
date: 2023-08-22 16:06:28
---


在前面的章节中，我们介绍了缓存的底层实现。我们一直假设计算机只有一个CPU核心，然而在现代的计算机体系结构中，CPU拥有多个核心。为了简单起见，如下图所示，每个核心都有一块独立的私有缓存，以及一个由所有核心共享的末级缓存(LLC)。

![多核处理器模型](https://s2.loli.net/2023/08/10/gT5WfKButCqpOSV.png)

## 缓存一致性问题

假设我们运行一个进程，其有两个线程，一个线程运行在C1，另一个线程运行在C2。从程序员的观点出发，这段代码是相当简单的。然而，我们需要从缓存的角度思考这个问题。

```c++
#include <thread>
using namespace std;

void C1(int *A) {
  *A = 43;
}

void C2(int *A) {
  while (*A == 42) {
    ;
  }
}

int main(int argc, char *argv[]) {
  int A = 42;
  thread thread1{C1, &A};
  thread thread2{C2, &A};

  thread2.join();
  thread1.join();

  return 0;

}
```

如下表所示：

+ Time 1时刻，对于C1来说，其需要对地址A写入值43，由于缓存未命中，其会将A的值42写入其私有缓存中。对于C2来说，其需要检查地址A的内容，由于缓存未命中，其会将A的值42写入其私有缓存中。(可能读者会想如果采取的*write-through*策略，C2有可能会读取到43的值，我们在这个例子中忽略这种情况，实际上如果涉及到两个核同时读写，*write-through*策略也会导致缓存的不一致性)
+ Time 2时刻，C2继续进行循环操作，由于其能命中其私有缓存，故其一直会进行死循环，然而实际上A的值应该是43。

| Time | Core C1   | Core C2            |
|------|-----------|--------------------|
| 1    | S1: A=43; | L1:while(A == 42); |
| 2    |           | L2:while(A == 42); |
| 3    |           | L3:while(A == 42); |
| 4    |           | ...                |
| n    |           | Ln:while(A == 42); |

从上述的过程可以得出一个重要的结论，多核问题会产生新的缓存不一致问题。由于私有缓存的存在，当某两个私有缓存指向的是同一个物理地址时，需要保持同步，维护一致性。

## 一致性问题解决通用方法

从上述的例子，我们其实可以很快地可以类比在多线程编程中的读写同步问题。当只读的时候，不存在不一致性问题，问题就在于写入缓存时。在实际的处理器中采用了*cache coherence protocol*，分为两类：

+ *Consistency-agnostic coherence*：首先需要将写入的这个事件通过缓存中的内部网络传递到其它核，再写入缓存。
+ *Consistency-directed coherence*：先写入缓存，再广播事件，常用于GPGPU。

## (Consistency-agnostic)缓存一致性不变量

我们能够确定一个十分明确的不变量，*single-writer-multiple-reader*(SWMR)，如下图所示，对于任一时刻，对于某一个内存地址来说，其要么有多个核心在执行读操作，要么只有一个核心在进行读写操作。

![SWMR](https://s2.loli.net/2023/08/10/Zs2ypk5TmYiIgHc.png)

同时我们还需要确保数据的一致性，内存位置的值与其最后一个读写时期结束时的值相同。因此我们可以明确如下的两个缓存一致性不变量：

1. **Single-Writer, Multiple-Read (SWMR) Invariant**.
2. **Data-Value Invariant**.

## 内存一致性模型


首先，我们提供一个简单的例子来阐述内存一致性模型的必要性。

|        Core C1        |           Core C2           |             Comments             |
|:---------------------:|:---------------------------:|:--------------------------------:|
| S1: Store data = NEW; |                             | Initially data = 0 & flag != SET |
| S2: Store flag = SET; | L1: Load r1 = flag;         | L1 & B1 may repeat many times    |
|                       | B1: if (r1 != SET) goto L1; |                                  |
|                       | L2: Load r2 = data;         |                                  |

从直观上来说，我们很容易认为`r2`的值应该是`NEW`。然后由于CPU指令乱序存在，整个执行顺序可能是`S2, L1, L2, S2`，从而`r2`的值是0。内存模型的关键就是定义了正确行为。

CPU并不会严格地按照程序中的内存访问顺序进行指令访问，其会进行如下三种的乱序执行：

1. **Store-store reordering**：两个`store`操作指令可以乱序执行。当某一个`store`指令没有命中缓存，而另一个`store`操作命中了缓存。
2. **Load-load reordering**
3. **Load-store and store-load reordering**

由此我们可以给出内存模型的定义：

> A *memory consistency model*, or more simply, a *memory model*, is a specification of the allowed behavior of multithread programs executing with shared memory. For a multithreaded program executing with specific input data, it specifies what values dynamic loads may return.

## Consistency与Coherence的区别

+ 缓存一致性与内存一致性是不相等的。
+ 内存一致性的实现可以基于缓存一致性。
