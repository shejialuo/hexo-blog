---
title: 多核处理器带来的缓存一致性问题
tags:
  - 技术
  - 学习
categories:
  - 缓存与内存专栏
date: 2023-08-22 16:06:28
---


在前面的章节中，我们介绍了缓存的底层实现。我们一直假设计算机只有一个CPU核心，然而在现代的计算机体系结构中，CPU拥有多个核心。为了简单起见，如下图所示，每个核心都有一块独立的私有缓存，以及一个由所有核心共享的末级缓存(LLC)。

![多核处理器模型](https://s2.loli.net/2023/08/10/gT5WfKButCqpOSV.png)

## 缓存一致性问题

假设我们运行一个进程，其有两个线程，一个线程运行在C1，另一个线程运行在C2。从程序员的观点出发，这段代码是相当简单的。然而，我们需要从缓存的角度思考这个问题。

```c++
#include <thread>
using namespace std;

void C1(int *A) {
  *A = 43;
}

void C2(int *A) {
  while (*A == 42) {
    ;
  }
}

int main(int argc, char *argv[]) {
  int A = 42;
  thread thread1{C1, &A};
  thread thread2{C2, &A};

  thread2.join();
  thread1.join();

  return 0;

}
```

如下表所示：

+ Time 1时刻，对于C1来说，其需要对地址A写入值43，由于缓存未命中，其会将A的值42写入其私有缓存中。对于C2来说，其需要检查地址A的内容，由于缓存未命中，其会将A的值42写入其私有缓存中。(可能读者会想如果采取的*write-through*策略，C2有可能会读取到43的值，我们在这个例子中忽略这种情况，实际上如果涉及到两个核同时读写，*write-through*策略也会导致缓存的不一致性)
+ Time 2时刻，C2继续进行循环操作，由于其能命中其私有缓存，故其一直会进行死循环，然而实际上A的值应该是43。

| Time | Core C1   | Core C2            |
|------|-----------|--------------------|
| 1    | S1: A=43; | L1:while(A == 42); |
| 2    |           | L2:while(A == 42); |
| 3    |           | L3:while(A == 42); |
| 4    |           | ...                |
| n    |           | Ln:while(A == 42); |

从上述的过程可以得出一个重要的结论，多核问题会产生新的缓存不一致问题。由于私有缓存的存在，当某两个私有缓存指向的是同一个物理地址时，需要保持同步，维护一致性。

## 一致性问题解决通用方法

从上述的例子，我们其实可以很快地可以类比在多线程编程中的读写同步问题。当只读的时候，不存在不一致性问题，问题就在于写入缓存时。在实际的处理器中采用了*cache coherence protocol*，分为两类：

+ *Consistency-agnostic coherence*：首先需要将写入的这个事件通过缓存中的内部网络传递到其它核，再写入缓存。
+ *Consistency-directed coherence*：先写入缓存，再广播事件，常用于GpGPU。

## (Consistency-agnostic)缓存一致性不变量

我们能够确定一个十分明确的不变量，*single-writer-multiple-reader(SWMR)*，如下图所示，对于任一时刻，对于某一个内存地址来说，其要么有多个核心在执行读操作，要么只有一个核心在进行读写操作。

![SWMR](https://s2.loli.net/2023/08/10/Zs2ypk5TmYiIgHc.png)

同时我们还需要确保数据的一致性，内存位置的值与其最后一个读写时期结束时的值相同。
